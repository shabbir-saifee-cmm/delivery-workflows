name: Full Terraform RC Pipeline

on:
  workflow_call:
    inputs:
      artifactConfigPath:
        description: 'Path to the artifact configuration file in the repository'
        required: true
        type: string
    secrets:
      TF_AUTOMATION_APP_ID:
        description: 'github app id for terraform-control repo access'
        required: true
      TF_AUTOMATION_APP_SECRET:
        description: 'github app secret for terraform-control repo access'
        required: true

jobs:
  complete-pipeline:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
      actions: write
    steps:
      # STEP 1: Validate comment and get PR details
      - name: Checkout terraform repo
        uses: actions/checkout@v3

      - name: Generate GitHub App Token
        id: app-token
        uses: actions/create-github-app-token@v1
        with:
          app-id: ${{ secrets.TF_AUTOMATION_APP_ID }}
          private-key: ${{ secrets.TF_AUTOMATION_APP_SECRET }}
          repositories: terraform-control

      - name: Get PR details
        id: pr-details
        uses: actions/github-script@v6
        with:
          script: |
            const fs = require('fs');
            const { owner, repo } = context.repo;
            const prNumber = context.payload.issue.number;
            const comment = context.payload.comment.body.trim();
            const commentPrefix = 'ready-to-test-terraform-';
            const forbiddenEnvs = ['prod', 'production'];

            // Read artifact configuration from file
            const artifactConfigPath = '${{ inputs.artifactConfigPath }}';
            console.log('Reading artifact config from:', artifactConfigPath);

            let artifactConfigYaml;
            try {
              artifactConfigYaml = fs.readFileSync(artifactConfigPath, 'utf8');
              console.log('Artifact config file content:', artifactConfigYaml);
            } catch (error) {
              core.setFailed(`Failed to read artifact configuration file at ${artifactConfigPath}: ${error.message}`);
              return;
            }

            let artifactConfig;
            try {
              // Simple YAML parser for the terraform config structure
              const yamlLines = artifactConfigYaml.split('\n').map(line => line.trim()).filter(line => line && !line.startsWith('#'));
              artifactConfig = { terraform: {} };

              let currentApp = null;
              for (const line of yamlLines) {
                if (line === 'terraform:') continue;

                if (line.endsWith(':') && !line.includes('moduleName') && !line.includes('modulePath')) {
                  // This is an app key
                  currentApp = line.replace(':', '').trim();
                  artifactConfig.terraform[currentApp] = {};
                } else if (currentApp && line.includes('moduleName:')) {
                  artifactConfig.terraform[currentApp].moduleName = line.split('moduleName:')[1].trim();
                } else if (currentApp && line.includes('modulePath:')) {
                  artifactConfig.terraform[currentApp].modulePath = line.split('modulePath:')[1].trim();
                }
              }
            } catch (error) {
              core.setFailed(`Failed to parse artifact configuration: ${error.message}`);
              return;
            }

            console.log('Parsed artifact config:', JSON.stringify(artifactConfig, null, 2));

            // Extract environment from comment
            const envRegex = new RegExp(`^${commentPrefix.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&')}(\\w+)$`);
            const envMatch = comment.match(envRegex);

            if (!envMatch) {
              core.setFailed(`Invalid comment format. Use: ${commentPrefix}<env>`);
              return;
            }

            const environment = envMatch[1].toLowerCase();

            if (forbiddenEnvs.includes(environment)) {
              core.setFailed(`‚ùå Automation not allowed for environment: ${environment}`);
              return;
            }

            const { data: pr } = await github.rest.pulls.get({
              owner,
              repo,
              pull_number: prNumber
            });

            const files = await github.paginate(
              github.rest.pulls.listFiles,
              { owner, repo, pull_number: prNumber, per_page: 100 }
            );

            // Check for changes in configured terraform modules
            const changedApps = new Set();

            for (const [appKey, appConfig] of Object.entries(artifactConfig.terraform)) {
              const modulePath = appConfig.modulePath;
              if (!modulePath) {
                console.log(`Warning: No modulePath configured for app ${appKey}`);
                continue;
              }

              // Remove leading ./ if present and ensure trailing slash
              const normalizedPath = modulePath.replace(/^\.\//, '').replace(/\/$/, '') + '/';
              console.log(`Checking for changes in ${normalizedPath} for app ${appKey}`);

              for (const file of files) {
                if (file.filename.startsWith(normalizedPath)) {
                  console.log(`Found change in ${file.filename} for app ${appKey}`);
                  changedApps.add(appKey);
                  break;
                }
              }
            }

            const appNameList = Array.from(changedApps);

            if (appNameList.length === 0) {
              const configuredPaths = Object.entries(artifactConfig.terraform)
                .map(([key, config]) => `${key}: ${config.modulePath}`)
                .join(', ');
              core.setFailed(`No app changes detected in configured terraform modules. Configured paths: ${configuredPaths}`);
              return;
            }

            console.log(`Found ${appNameList.length} changed module(s): ${appNameList.join(', ')}`);

            // Store all changed apps and their configurations
            const changedModules = appNameList.map(appKey => {
              const appConfig = artifactConfig.terraform[appKey];
              return {
                appKey: appKey,
                appName: appConfig.moduleName || appKey,
                modulePath: appConfig.modulePath
              };
            });

            const prAuthor = pr.user.login;

            core.setOutput("head_branch", pr.head.ref);
            core.setOutput("head_sha", pr.head.sha);
            core.setOutput("pr_number", prNumber);
            core.setOutput("environment", environment);
            core.setOutput("pr_author", prAuthor);
            core.setOutput("changed_modules", JSON.stringify(changedModules));

            core.info(`‚úÖ Changed modules: ${changedModules.map(m => `${m.appKey} (${m.modulePath})`).join(', ')}, Env: ${environment}`);

      # STEP 2: Create RC tags for all changed modules
      - name: Create RC tags for changed modules
        id: create-tags
        run: |
          set -e

          BRANCH_NAME=${{ steps.pr-details.outputs.head_branch }}
          SHA=${{ steps.pr-details.outputs.head_sha }}
          AUTHOR=${{ steps.pr-details.outputs.pr_author }}
          CHANGED_MODULES='${{ steps.pr-details.outputs.changed_modules }}'

          echo "üîß Branch: $BRANCH_NAME"
          echo "üîß Commit SHA: $SHA"
          echo "üîß Changed modules: $CHANGED_MODULES"

          # Clean branch name (remove special characters, convert to lowercase)
          CLEAN_BRANCH=$(echo "$BRANCH_NAME" | sed 's/[^a-zA-Z0-9-]/-/g' | tr '[:upper:]' '[:lower:]')
          echo "üîß Clean branch: $CLEAN_BRANCH"

          # Fetch tags from remote
          git fetch --tags origin

          # Parse JSON and create tags for each module
          CREATED_TAGS=""
          CREATED_VERSIONS=""

          echo "$CHANGED_MODULES" | jq -r '.[] | @base64' | while read -r module_data; do
            module=$(echo "$module_data" | base64 -d)
            APP_KEY=$(echo "$module" | jq -r '.appKey')
            APP_NAME=$(echo "$module" | jq -r '.appName')
            MODULE_PATH=$(echo "$module" | jq -r '.modulePath')

            echo "üè∑Ô∏è Processing module: $APP_KEY"
            echo "   - Name: $APP_NAME"
            echo "   - Path: $MODULE_PATH"

            # Use app key (not app name) for tag - this is the config key
            TAG_PREFIX="rc/terraform/${APP_KEY}"
            VERSION_PREFIX="0.0.0-${CLEAN_BRANCH}"

            # Get latest RC tag for this app key and branch
            LATEST_TAG=$(git tag --list "${TAG_PREFIX}/${VERSION_PREFIX}-*" | sort -V | tail -n 1)
            echo "üîç Latest tag for ${APP_KEY}: ${LATEST_TAG:-none}"

            if [[ -z "$LATEST_TAG" ]]; then
              NEW_RC_NUM=1
            else
              # Extract the incrementor number from the tag
              RC_NUM=$(echo $LATEST_TAG | sed -E "s|.*${VERSION_PREFIX//./\\.}-([0-9]+)$|\1|")
              if [[ -z "$RC_NUM" || ! "$RC_NUM" =~ ^[0-9]+$ ]]; then
                echo "‚ö†Ô∏è Could not extract RC number from $LATEST_TAG, starting from 1"
                NEW_RC_NUM=1
              else
                NEW_RC_NUM=$((RC_NUM + 1))
              fi
            fi

            # Create the new tag and version
            NEW_VERSION="${VERSION_PREFIX}-${NEW_RC_NUM}"
            NEW_TAG="${TAG_PREFIX}/${NEW_VERSION}"

            # Check if tag already exists (local or remote)
            while git rev-parse "$NEW_TAG" >/dev/null 2>&1; do
              echo "Tag $NEW_TAG already exists, incrementing RC number"
              NEW_RC_NUM=$((NEW_RC_NUM + 1))
              NEW_VERSION="${VERSION_PREFIX}-${NEW_RC_NUM}"
              NEW_TAG="${TAG_PREFIX}/${NEW_VERSION}"
            done

            echo "üè∑Ô∏è Creating tag: $NEW_TAG"
            echo "üì¶ Version: $NEW_VERSION"

            # Create and push the tag
            git tag $NEW_TAG $SHA
            git push origin $NEW_TAG

            # Collect results (append to files since we're in a subshell)
            echo "${APP_KEY}:${NEW_TAG}" >> /tmp/created_tags.txt
            echo "${APP_KEY}:${NEW_VERSION}" >> /tmp/created_versions.txt
          done

          # Read results from files
          if [ -f /tmp/created_tags.txt ]; then
            CREATED_TAGS=$(cat /tmp/created_tags.txt | tr '\n' ',' | sed 's/,$//')
            CREATED_VERSIONS=$(cat /tmp/created_versions.txt | tr '\n' ',' | sed 's/,$//')
            rm /tmp/created_tags.txt /tmp/created_versions.txt
          fi

          echo "created_tags=$CREATED_TAGS" >> $GITHUB_OUTPUT
          echo "created_versions=$CREATED_VERSIONS" >> $GITHUB_OUTPUT

          echo "‚úÖ Created tags: $CREATED_TAGS"
          echo "‚úÖ Created versions: $CREATED_VERSIONS"

      # STEP 3: Publish terraform modules
      - name: Publish terraform modules
        id: publish
        run: |
          set -e

          CHANGED_MODULES='${{ steps.pr-details.outputs.changed_modules }}'
          CREATED_TAGS="${{ steps.create-tags.outputs.created_tags }}"
          CREATED_VERSIONS="${{ steps.create-tags.outputs.created_versions }}"

          echo "üì¶ Publishing modules..."
          echo "üì¶ Created tags: $CREATED_TAGS"
          echo "üì¶ Created versions: $CREATED_VERSIONS"

          # Parse and publish each module
          echo "$CHANGED_MODULES" | jq -r '.[] | @base64' | while read -r module_data; do
            module=$(echo "$module_data" | base64 -d)
            APP_KEY=$(echo "$module" | jq -r '.appKey')
            APP_NAME=$(echo "$module" | jq -r '.appName')

            echo "üì¶ Publishing module: $APP_KEY ($APP_NAME)"

            # Add your actual publishing logic here for each module
            # This could be:
            # - Publishing to Terraform Cloud/Enterprise
            # - Publishing to a private registry
            # - Building and uploading artifacts

            # Simulate publishing for now
            sleep 1
          done

          echo "‚úÖ All modules published successfully"
          echo "status=success" >> $GITHUB_OUTPUT

      # STEP 4: Update control repo for all changed modules (single PR)
      - name: Update versions in terraform-control and open single PR
        id: update-control
        env:
          GH_TOKEN: ${{ steps.app-token.outputs.token }}
        run: |
          set -e

          CHANGED_MODULES='${{ steps.pr-details.outputs.changed_modules }}'
          CREATED_TAGS="${{ steps.create-tags.outputs.created_tags }}"
          CREATED_VERSIONS="${{ steps.create-tags.outputs.created_versions }}"
          AUTHOR=${{ steps.pr-details.outputs.pr_author }}
          PR_NUMBER=${{ steps.pr-details.outputs.pr_number }}
          ENV=${{ steps.pr-details.outputs.environment }}
          BRANCH_NAME=${{ steps.pr-details.outputs.head_branch }}

          CONTROL_REPO="shabbir-saifee-cmm/terraform-control"
          CONTROL_CLONE="terraform-control"

          # Single branch for all module updates
          UPDATE_BRANCH_NAME="auto-update-multi-module-$(echo ${BRANCH_NAME} | sed 's/[^a-zA-Z0-9-]/-/g' | tr '[:upper:]' '[:lower:]')-${PR_NUMBER}"

          # Clone control repo
          gh repo clone $CONTROL_REPO $CONTROL_CLONE
          cd $CONTROL_CLONE

          git config user.name "github-actions"
          git config user.email "github-actions@github.com"

          # Convert tags and versions to arrays for processing
          IFS=',' read -ra TAG_PAIRS <<< "$CREATED_TAGS"
          IFS=',' read -ra VERSION_PAIRS <<< "$CREATED_VERSIONS"

          # Check if remote branch exists, else create from main
          if git ls-remote --heads origin $UPDATE_BRANCH_NAME | grep $UPDATE_BRANCH_NAME; then
            git checkout $UPDATE_BRANCH_NAME
            git pull origin $UPDATE_BRANCH_NAME
          else
            git checkout -b $UPDATE_BRANCH_NAME origin/main
          fi

          UPDATED_MODULES=""
          UPDATED_FILES=""

          # Process each changed module in the same branch
          echo "$CHANGED_MODULES" | jq -r '.[] | @base64' | while read -r module_data; do
            module=$(echo "$module_data" | base64 -d)
            APP_KEY=$(echo "$module" | jq -r '.appKey')
            APP_NAME=$(echo "$module" | jq -r '.appName')
            MODULE_PATH=$(echo "$module" | jq -r '.modulePath')

            # Get tag and version for this module
            NEW_TAG=""
            NEW_VERSION=""
            for pair in "${TAG_PAIRS[@]}"; do
              if [[ "$pair" == "$APP_KEY:"* ]]; then
                NEW_TAG="${pair#*:}"
                break
              fi
            done
            for pair in "${VERSION_PAIRS[@]}"; do
              if [[ "$pair" == "$APP_KEY:"* ]]; then
                NEW_VERSION="${pair#*:}"
                break
              fi
            done

            echo "üîÑ Processing control repo update for: $APP_KEY"
            echo "   - Module Name: $APP_NAME"
            echo "   - New Tag: $NEW_TAG"
            echo "   - New Version: $NEW_VERSION"

            # Update file - use APP_KEY for directory structure
            FILE_PATH="projects/${APP_KEY}/${ENV}/main.tf"

            if [ ! -f "$FILE_PATH" ]; then
              echo "‚ùå File not found: $FILE_PATH"
              echo "Available files in projects/${APP_KEY}:"
              find projects/${APP_KEY} -name "*.tf" 2>/dev/null || echo "No terraform files found"

              # Try with APP_NAME if APP_KEY doesn't work
              FILE_PATH="projects/${APP_NAME}/${ENV}/main.tf"
              if [ ! -f "$FILE_PATH" ]; then
                echo "‚ùå File also not found: $FILE_PATH"
                continue
              fi
            fi

            echo "üìù Updating $FILE_PATH with version $NEW_VERSION"

            # Update version with the version format (not the full tag)
            sed -i -E "0,/^(\s*version)(\s*=\s*)\"[^\"]+\"/s//\1\2\"${NEW_VERSION}\"/" $FILE_PATH

            git add $FILE_PATH

            # Collect info for commit message and PR body
            echo "${APP_KEY}:${NEW_VERSION}:${NEW_TAG}" >> /tmp/updated_modules.txt
            echo "- $FILE_PATH" >> /tmp/updated_files.txt
          done

          # Read collected information
          if [ -f /tmp/updated_modules.txt ]; then
            UPDATED_MODULES=$(cat /tmp/updated_modules.txt)
            UPDATED_FILES=$(cat /tmp/updated_files.txt)
            rm /tmp/updated_modules.txt /tmp/updated_files.txt
          fi

          # Count modules
          MODULE_COUNT=$(echo "$UPDATED_MODULES" | wc -l)

          # Create commit message with all modules
          COMMIT_MSG="Update ${MODULE_COUNT} module(s) to new versions

          Environment: ${ENV}
          Source Branch: ${BRANCH_NAME}

          Updated modules:"

          while IFS= read -r line; do
            if [ ! -z "$line" ]; then
              IFS=':' read -r app_key version tag <<< "$line"
              COMMIT_MSG="${COMMIT_MSG}
          - ${app_key}: ${version} (${tag})"
            fi
          done <<< "$UPDATED_MODULES"

          COMMIT_MSG="${COMMIT_MSG}

          Co-authored-by: ${AUTHOR} <${AUTHOR}@users.noreply.github.com>"

          git commit -m "$COMMIT_MSG" || echo "No changes to commit"

          # Push branch
          git remote set-url origin https://x-access-token:${GH_TOKEN}@github.com/${CONTROL_REPO}.git
          git push --force-with-lease origin $UPDATE_BRANCH_NAME

          # Check if PR exists
          EXISTING_PR=$(gh pr list --repo $CONTROL_REPO --head $UPDATE_BRANCH_NAME --json number --jq '.[0].number')

          if [ -z "$EXISTING_PR" ]; then
            # Create PR body using echo statements instead of here-documents
            echo "This PR updates ${MODULE_COUNT} module(s) to new versions in \`${ENV}\`." > pr_body_multi.md
            echo "" >> pr_body_multi.md
            echo "## üìã Updated Modules" >> pr_body_multi.md

            # Add each module to PR body
            while IFS= read -r line; do
              if [ ! -z "$line" ]; then
                IFS=':' read -r app_key version tag <<< "$line"
                echo "- **${app_key}**: \`${version}\` (tag: \`${tag}\`)" >> pr_body_multi.md
              fi
            done <<< "$UPDATED_MODULES"

            echo "" >> pr_body_multi.md
            echo "## üìÇ Updated Files" >> pr_body_multi.md
            echo "${UPDATED_FILES}" >> pr_body_multi.md
            echo "" >> pr_body_multi.md
            echo "## üîó Source Information" >> pr_body_multi.md
            echo "- **Environment**: \`${ENV}\`" >> pr_body_multi.md
            echo "- **Source Branch**: \`${BRANCH_NAME}\`" >> pr_body_multi.md
            echo "- **Triggered by**: [@${AUTHOR}](https://github.com/${AUTHOR})" >> pr_body_multi.md
            echo "- **Source PR**: [#${PR_NUMBER}](https://github.com/${{ github.repository }}/pull/${PR_NUMBER}) in [\`${{ github.repository }}\`](https://github.com/${{ github.repository }})" >> pr_body_multi.md
            echo "" >> pr_body_multi.md
            echo "---" >> pr_body_multi.md
            echo "*This PR was automatically created by the terraform automation system.*" >> pr_body_multi.md

            # Create title based on module count
            if [ "$MODULE_COUNT" -eq 1 ]; then
              FIRST_MODULE=$(echo "$UPDATED_MODULES" | head -n1 | cut -d':' -f1)
              FIRST_VERSION=$(echo "$UPDATED_MODULES" | head -n1 | cut -d':' -f2)
              PR_TITLE="Update ${FIRST_MODULE} module to ${FIRST_VERSION} (${BRANCH_NAME}) by @${AUTHOR}"
            else
              PR_TITLE="Update ${MODULE_COUNT} modules (${BRANCH_NAME}) by @${AUTHOR}"
            fi

            gh pr create --title "$PR_TITLE" \
              --body-file pr_body_multi.md \
              --base main --head $UPDATE_BRANCH_NAME \
              --assignee $AUTHOR \
              --reviewer $AUTHOR

            echo "‚úÖ Created new PR for ${MODULE_COUNT} module updates"
          else
            echo "‚úÖ Updated existing PR #$EXISTING_PR for ${MODULE_COUNT} modules"
          fi

          PR_URL=$(gh pr list --repo $CONTROL_REPO --head $UPDATE_BRANCH_NAME --json url --jq '.[0].url')

          if [ -z "$PR_URL" ]; then
            COMMIT_SHA=$(git rev-parse HEAD)
            PR_URL="https://github.com/${CONTROL_REPO}/commit/${COMMIT_SHA}"
            MSG="üîÑ Updated ${MODULE_COUNT} module(s) in [terraform-control](${PR_URL}) (commit only)"
          else
            MSG="üì¶ [Multi-module PR](${PR_URL}) - ${MODULE_COUNT} module(s) updated"
          fi

          echo "control_message=$MSG" >> $GITHUB_OUTPUT

      # STEP 5: Final status comment
      - name: Comment on PR with final status
        uses: actions/github-script@v6
        with:
          script: |
            const changedModules = JSON.parse('${{ steps.pr-details.outputs.changed_modules }}');
            const createdTags = '${{ steps.create-tags.outputs.created_tags }}';
            const createdVersions = '${{ steps.create-tags.outputs.created_versions }}';
            const environment = '${{ steps.pr-details.outputs.environment }}';
            const branchName = '${{ steps.pr-details.outputs.head_branch }}';
            const controlMessage = '${{ steps.update-control.outputs.control_message }}';
            const workflowUrl = `${context.serverUrl}/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId}`;

            // Parse tags and versions
            const tagMap = {};
            const versionMap = {};

            createdTags.split(',').forEach(pair => {
              const [key, value] = pair.split(':');
              tagMap[key] = value;
            });

            createdVersions.split(',').forEach(pair => {
              const [key, value] = pair.split(':');
              versionMap[key] = value;
            });

            // Build module summary
            let moduleSummary = '';
            changedModules.forEach(module => {
              const tag = tagMap[module.appKey] || 'N/A';
              const version = versionMap[module.appKey] || 'N/A';
              moduleSummary += `- **${module.appKey}** (\`${module.modulePath}\`): \`${version}\`\n`;
            });

            // Build tags list
            let tagsList = '';
            changedModules.forEach(module => {
              const tag = tagMap[module.appKey] || 'N/A';
              tagsList += `- \`${tag}\`\n`;
            });

            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: ${{ steps.pr-details.outputs.pr_number }},
              body: `üéâ **Terraform RC Pipeline Complete!**

              ## üìã Summary
              - **Environment**: \`${environment}\`
              - **Source Branch**: \`${branchName}\`
              - **Modules Processed**: ${changedModules.length}

              ## üì¶ Updated Modules
              ${moduleSummary}

              ## üè∑Ô∏è Created Tags
              ${tagsList}

              ## ‚úÖ Pipeline Steps
              1. ‚úÖ **Tags Created**: ${changedModules.length} RC tag(s) created
              2. ‚úÖ **Modules Published**: All modules published to Terraform registry
              3. ‚úÖ **Control Repo Updated**: ${controlMessage}

              All module changes are consolidated in a single control repo PR for easier review and deployment!

              [View Workflow Run](${workflowUrl})`
            });
